use std::borrow::BorrowMut;
use std::boxed::Box;
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};

use jsi::{JsiValue, PropName, RuntimeClone, RuntimeHandle};

use crate::console_log;

pub type CallbackType<'a> = Arc<
    dyn Fn() -> Pin<Box<dyn Future<Output = anyhow::Result<JsiValue<'a>>> + Send + 'a>>
        + Send
        + Sync
        + 'a,
>;

pub fn clone_runtime_handle<'rt>(handle: &mut RuntimeHandle<'rt>) -> RuntimeHandle<'static> {
    let inner_runtime_ptr: *mut jsi::sys::Runtime =
        { handle.get_inner() as *const jsi::sys::Runtime as *mut jsi::sys::Runtime };

    RuntimeHandle::new_unchecked(inner_runtime_ptr)
}

pub struct SendableRuntimeHandle {
    inner: RuntimeHandle<'static>,
}

impl SendableRuntimeHandle {
    pub fn new(handle: RuntimeHandle<'static>) -> Self {
        SendableRuntimeHandle { inner: handle }
    }

    pub fn get_inner(&self) -> &RuntimeHandle<'static> {
        &self.inner
    }

    pub fn get_inner_mut(&mut self) -> &mut RuntimeHandle<'static> {
        &mut self.inner
    }
}

unsafe impl Send for SendableRuntimeHandle {}

pub fn make_async<'rt>(
    rt: &mut jsi::RuntimeHandle<'rt>,
    callback: CallbackType<'static>,
) -> anyhow::Result<jsi::JsiValue<'rt>> {
    let mut sendable_handle = SendableRuntimeHandle::new(clone_runtime_handle(rt));

    console_log("jsi::create_promise", rt).ok();

    let promise = jsi::create_promise(
        move |resolve: jsi::JsiFn, reject: jsi::JsiFn, _rt: &mut jsi::RuntimeHandle| {
            // Arc<Mutex> to make type system happy since JsiValues
            // aren't Sync; inexpensive b/c we will only access each
            // function at most once
            let resolve = std::sync::Arc::new(std::sync::Mutex::new(resolve));
            let reject = std::sync::Arc::new(std::sync::Mutex::new(reject));

            console_log("got promise -> spawn thread", _rt).ok();

            std::thread::spawn(async move || {
                let rt = sendable_handle.get_inner_mut();

                println!("thread spawned native");

                console_log("thread spawned", rt).ok();

                let res = callback().await;

                console_log("callback finished", rt).ok();

                match res {
                    Ok(val) => {
                        let val = jsi::IntoValue::into_value(val, rt);

                        console_log("resolve promise", rt).ok();

                        resolve.lock().unwrap().call(std::iter::once(val), rt)?;

                        console_log("resolved", rt).ok();
                    }
                    Err(err) => {
                        // reject.lock().unwrap().call(std::iter::empty(), rt)?;

                        console_log("reject promise", rt).ok();

                        // for some reason, just calling reject() doesn't actually cause
                        // the promise to reject, so instead we create a rejected
                        // promise and return that

                        let promise_ctor = rt.global().get(jsi::PropName::new("Promise", rt), rt);
                        let promise_ctor: jsi::JsiObject =
                            jsi::FromValue::from_value(&promise_ctor, rt)
                                .expect("Promise constructor is not an object");
                        let promise_reject: jsi::JsiFn = jsi::FromValue::from_value(
                            &promise_ctor.get(jsi::PropName::new("reject", rt), rt),
                            rt,
                        )
                        .expect("Promise.reject is not a function");

                        let rt_clone = &mut clone_runtime_handle(rt);

                        let err = jsi::js_error!(rt_clone, "{err}");
                        let err = jsi::IntoValue::into_value(err, rt);

                        let rejection = promise_reject.call(std::iter::once(err), rt).unwrap();
                        reject
                            .lock()
                            .unwrap()
                            .call(std::iter::once(rejection), rt)?;

                        console_log("rejected", rt).ok();
                    }
                }

                Ok::<(), anyhow::Error>(()) // Explicitly specify the type of Ok
            });
        },
        &mut clone_runtime_handle(rt),
    );

    Ok(jsi::IntoValue::into_value(promise, rt))
}
